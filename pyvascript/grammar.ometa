grammar = line*:l spaces end -> l

indent             = hspace*:h -> len(h)
extraindent :start = indent:i ?(i > start) -> i

hspace    = ' ' | '\t'
vspace    = '\n'
optspace  = ?(self.parenthesis) (hspace | '\\'? vspace)* | (hspace | '\\' vspace)*
mandspace = ?(self.parenthesis) (hspace | '\\'? vspace)+ | (hspace | '\\' vspace)+

emptyline = hspace* vspace
line      = emptyline* indent:i stmtorcomment:s vspace -> s
line_rest = (~vspace :x)*:x -> ''.join(x)

stmtorcomment = comment
              | stmt:s
                (hspace* comment:c -> ['inlinecomment', s, c]
                | -> s)

stmt = expr

comment  = '#' line_rest:c -> ['comment', c]

expr = orop

orop  = orop:l optspace "or":op andop:r -> ['binop', op, l, r]
      | andop
andop = andop:l optspace "and":op notop:r -> ['binop', op, l, r]
      | notop
notop = optspace "not":op mandspace notop:r -> ['unop', op, r]
      | cmpop
comparison = "in"
           | "not" mandspace "in" -> 'not in'
           | "is" mandspace "not" -> 'is not'
           | "is" | "<" | "<=" | ">" | ">=" | "!=" | "=="
cmpop = cmpop:l optspace comparison:op mandspace bitor:r -> ['binop', op, l, r]
      | bitor
bitor = bitor:l optspace '|':op bitxor:r -> ['binop', op, l, r]
      | bitxor
bitxor = bitxor:l optspace '^':op bitand:r -> ['binop', op, l, r]
      | bitand
bitand = bitand:l optspace '&':op shift:r -> ['binop', op, l, r]
      | shift
shift = shift:l optspace ("<<" | ">>"):op addop:r -> ['binop', op, l, r]
      | addop
addop = addop:l optspace ('+' | '-'):op mulop:r -> ['binop', op, l, r]
      | mulop
mulop = mulop:l optspace ('*' | '/' | '//' | '%'):op unop:r -> ['binop', op, l, r]
      | unop
unop  = optspace ('-' | '+' | '~'):op unop:e -> ['unop', op, e]
      | primary

primary = optspace
          (number
          | funcall
          | name
          | string
          | '(' !(self.enter_paren()) expr:ix optspace ')' !(self.leave_paren()) -> ix)

funcall = name:n optspace '(' optspace ')' -> ['call', n]

name_start   = letter | '$' | '_'
name_rest    = name_start | digit
iname        = name_start:s name_rest*:r   -> s + ''.join(r)
iskeyword :x = ?(self.is_keyword(x))
name         = iname:n ~iskeyword(n)       -> ['name', n]
keyword      = iname:k iskeyword(k)        -> [k, k]

escaped_char = '\\' :x -> ('\\' + x).decode('string_escape')
string_in_quotes :e = match_string(e) (escaped_char | ~(?(len(e) != 3) vspace | match_string(e)) anything)*:c match_string(e) -> ['string', ''.join(c)]
string = string_in_quotes('"""') | string_in_quotes("'''") | string_in_quotes('"') | string_in_quotes("'")

hexdigit     = letterOrDigit:x !(self.hex_digits.find(x.lower())):v ?(v >= 0)  -> v
hexlit       = hexlit:n hexdigit:d                                             -> (n * 16 + d)
             | hexdigit
number       = "0x" hexlit:n                                                   -> ['hexnumber', n]
             | digit+:ws ('.' digit+:fs                                        -> ['number', float('%s.%s' % (''.join(ws), ''.join(fs)))]
                         | -> ['number'])                                      -> ['number', int(''.join(ws))]

csvs   =  -> v
array  = '[' csvs?:v ']' -> ['array', v]
