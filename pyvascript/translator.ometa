grammar = stmt*:s -> '\n'.join(s) + '\n'

stmt = comment
     | inlinecomment
     | expr:e             -> '%s;' % e
expr  = [:t apply(t):ans] -> ans

comment       = ['comment' :c]                     -> '//%s' % c
inlinecomment = ['inlinecomment' expr:e comment:c] -> '%s; %s' % (e, c)

assign   expr:lhs :op expr:rhs -> '%s = %s'
getitem  expr:x expr:fd        -> '%s[%s]' % (x, fd)

self            -> 'this'
break           -> 'break'
continue        -> 'continue'
return   expr:x -> 'return %s' % x

name      :n       -> n
number    :n       -> str(n)
hexnumber :n       -> hex(n)
string    :s       -> self.to_string(s)
array     expr*:xs -> '[%s]' % xs.join(', ')
dict      expr*:xs -> '[%s]' % xs.join(', ')

unop     :op expr:x        -> '(%s%s)' % (self.op_map.get(op, op), x)
binop    :op expr:x expr:y -> '(%s %s %s)' % (x, op, y)

if       expr:cond block:t block:e         -> 'if(%s) %s else %s' % (cond, t, e)
ifExpr   expr:cond expr:t expr:e                   -> '(%s ? %s : %s)' % (cond, t, e)
while    expr:cond block:body                   -> 'while(%s) %s' % (cond, body)
for      expr:x expr:arr block:body            -> 'for(%s in %s) %s' % (x, arr, body)

func     :args block:body                        -> ('(function (' + args.join(',') + ')' + body + ')')

call     expr:fn expr*:args                         -> '%s(%s)' % (fn, ', '.join(args))
raise    expr:x                                      -> ('throw ' + x)
try      block:x :name block:c block:f -> ('try ' + x + 'catch(' + name + ')' + c + 'finally' + f)
