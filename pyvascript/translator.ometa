grammar = stmt*:s -> '%s\n' % '\n'.join(s)

block = [stmt*:s] -> '{\n%s\n}' % '\n'.join(s)
stmt = (['while' while:e]
        | ['if' if:e]
        | ['for' for:e]) -> e
     | expr:e            -> '%s;' % e
expr = [:t apply(t):ans] -> ans

unop     :op expr:x        -> '(%s%s)' % (self.op_map.get(op, op), x)
binop    :op expr:x expr:y -> '(%s %s %s)' % (x, op, y)

name      :n       -> n
number    :n       -> str(n)
hexnumber :n       -> hex(n)
string    :s       -> self.to_string(s)

new expr:c              -> 'new %s' % c
call expr:fn expr*:args -> '%s(%s)' % (fn, ', '.join(args))

list  expr*:xs -> '[%s]' % ', '.join(xs)
tuple expr*:xs -> 'tuple([%s])' % ', '.join(xs)
set   expr*:xs -> 'set([%s])' % ', '.join(xs)
dict  expr*:xs -> '{%s}' % ', '.join(xs)

dictkv expr:k expr:v -> '%s: %s' % (k, v)

assign   expr:lhs :op expr:rhs -> '%s = %s'
getitem  expr:x expr:fd        -> '%s[%s]' % (x, fd)

self            -> 'this'
break           -> 'break'
pass            -> ''
continue        -> 'continue'
return   expr:x -> 'return %s' % x

while expr:cond block:body        -> 'while(%s) %s' % (cond, ''.join(body))
if    expr:cond block:t block?:e  -> 'if(%s) %s else %s' % (cond, t, e) if e else 'if(%s) %s' % (cond, t)
for   expr:x expr:arr block:body  -> 'for(%s in %s) %s' % (x, arr, body)

ifExpr   expr:cond expr:t expr:e                   -> '(%s ? %s : %s)' % (cond, t, e)

func     :args block:body                        -> ('(function (' + args.join(',') + ')' + body + ')')

raise    expr:x                                      -> ('throw ' + x)
try      block:x :name block:c block:f -> ('try ' + x + 'catch(' + name + ')' + c + 'finally' + f)
