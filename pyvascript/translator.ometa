grammar = stmt*:s -> '%s\n' % '\n'.join(s)

block = [stmt*:s] -> '{\n%s\n}' % '\n'.join(s)
stmt = (['while' while:e]
        | ['if' if:e]
        | ['for' for:e]) -> e
     | ['pass'] -> ''
     | expr:e            -> '%s;' % e
expr = [:t apply(t):ans] -> ans

unop     :op expr:x        -> '(%s%s)' % (self.op_map.get(op, op), x)
binop    :op expr:x expr:y -> '(%s %s %s)' % (x, op, y)

name      :n       -> n
number    :n       -> str(n)
hexnumber :n       -> hex(n)
string    :s       -> self.to_string(s)

new expr:c              -> 'new %s' % c
call expr:fn expr*:args -> '%s(%s)' % (fn, ', '.join(args))

list  expr*:xs -> '[%s]' % ', '.join(xs)
tuple expr*:xs -> '$py_tuple([%s])' % ', '.join(xs)
set   expr*:xs -> '$py_set([%s])' % ', '.join(xs)
dict  expr*:xs -> '{%s}' % ', '.join(xs)

dictkv expr:k expr:v -> '%s: %s' % (k, v)

assign   expr:lhs :op expr:rhs -> '%s = %s'
getitem  expr:x expr:fd        -> '%s[%s]' % (x, fd)

self            -> 'this'
break           -> 'break'
continue        -> 'continue'
return   expr:x -> 'return %s' % x

while expr:cond block:body -> 'while(%s) %s' % (cond, ''.join(body))

if [expr:cond block:t] [([expr:c block:b] -> (c, b))*:ei] block?:e -> self.make_if(cond, t, ei, e)

for expr:var expr:data block:body -> '$py_for(%s, function(%s) %s)' % (data, var, body)

func :name [expr*:args] block:body -> self.make_func(name, args, body)
