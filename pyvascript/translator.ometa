grammar = stmt*:s -> '%s\n' % '\n'.join(s)

block = ~~[anything*] !(self.indent()):i [stmt*:s] !(self.dedent()) -> self.make_block(s, i)
funcblock = ~~[anything*] !(self.indent()):i [stmt*:s] !(self.dedent()) -> self.make_func_block(s, i)
stmt = (  ['while' while:e]
        | ['if' if:e]
        | ['for' for:e]
        | ['try' try:e]
        | ['func' func:e]) -> '%s\n' % e
     | ['global' [expr*:names]] !(self.register_globals(names)) -> ''
     | ['pass'] -> ''
     | expr:e            -> '%s;' % e
expr = [:t apply(t):ans] -> ans

augassign :op expr:l expr:r !(self.register_var(l)) -> '%s %s %s' % (l, op, r)
assign expr:l expr:r !(self.register_var(l)) -> '%s = %s' % (l, r)

get     expr:x expr:y     -> '%s.%s' % (x, y)
getitem expr:x [expr+:fd] -> '%s[%s]' % (x, ', '.join(fd))

unop     :op expr:x        -> '(%s%s)' % (self.op_map.get(op, op), x)
binop    :op expr:x expr:y -> '(%s %s %s)' % (x, self.binop_map.get(op, op), y)

name      :n       -> self.name_map.get(n, n)
number    :n       -> str(n)
hexnumber :n       -> hex(n)
string    :s       -> '"%s"' % s.encode('string_escape')

new  expr:c                  -> 'new %s' % c
call (['name' 'JS'] ([['string' :js]] -> '(%s)' % js
                    |[expr:js]        -> 'eval(%s)' % js
                    )
     | expr:fn [expr*:args]           -> '%s(%s)' % (fn, ', '.join(args))
     )

list  !(self.indent()) expr*:xs !(self.dedent()) -> '[%s]' % ', '.join(xs)
tuple !(self.indent()) expr*:xs !(self.dedent()) -> '_$pyva_tuple([%s])' % ', '.join(xs)
set   !(self.indent()) expr*:xs !(self.dedent()) -> '_$pyva_set([%s])' % ', '.join(xs)
dict  !(self.indent()):i expr*:xs !(self.dedent()) -> self.make_dict(xs, i)

dictkv expr:k expr:v -> '%s: %s' % (k, v)

self            -> 'this'
break           -> 'break'
continue        -> 'continue'
return   expr:x -> 'return %s' % x
raise    expr:x -> 'throw %s' % x

while expr:cond block:body -> 'while (%s) %s' % (cond, ''.join(body))

if [expr:cond block:t] [([expr:c block:b] -> (c, b))*:ei] block?:e -> self.make_if(cond, t, ei, e)
ifexpr expr:cond expr:t expr:f -> '(%s ? %s : %s)' % (cond, t, f)

for expr:var !(self.register_var(var))
    ( ['call' ['name' 'range'] [expr+:r ?(len(r) <= 3)]] block:body -> self.make_for_range(var, r, body)
    | ['call' ['name' 'reversed'] [['call' ['name' 'range'] [expr+:r ?(len(r) <= 3)]]]] block:body -> self.make_for_reversed_range(var, r, body)
    | expr:data block:body -> self.make_for(var, data, body)
    )

func !(self.push_vars()) :name [expr*:args] !(self.register_globals(args)) funcblock:body !(self.pop_vars()) -> self.make_func(name, args, body)

try block:body expr:err block:errbody block?:finbody -> 'try %s catch(%s) %s' % (body, err, errbody) + (' finally %s' % finbody if finbody else '')
