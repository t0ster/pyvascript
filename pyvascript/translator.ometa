trans      = [:t apply(t):ans]     -> ans
curlyTrans = [`begin curlyTrans:r] -> r
         | [`begin trans*:rs]    -> ('{' + rs.join(';') + '}')
         | trans:r               -> ('{' + r + '}')

self                                                  -> 'this'
break                                                 -> 'break'
continue                                              -> 'continue'
number   :n                                           -> '(%s)' % n
string   :s                                           -> self.to_string(s)
array    trans*:xs                                    -> '[' + xs.join(', ') + ']'
unop     :op trans:x                                  -> '(%s%s)' % (op, x)
binop    :op trans:x trans:y                          -> '(%s %s %s)' % (x, op, y)
getitem  trans:x trans:fd                             -> '%s[%s]' % (x, fd)
assign   trans:lhs :op trans:rhs                      -> '%s = %s'
return   trans:x                                      -> 'return %s' % x

if       trans:cond curlyTrans:t curlyTrans:e         -> ('if(' + cond + ') ' + t + 'else' + e)
condExpr trans:cond trans:t trans:e                   -> ('(' + cond + '?' + t + ':' + e + ')')
while    trans:cond curlyTrans:body                   -> ('while(' + cond + ')' + body)
doWhile  curlyTrans:body trans:cond                   -> ('do' + body + 'while(' + cond + ')')
for      trans:init trans:cond trans:upd
         curlyTrans:body                              -> ('for(' + init + ';' + cond + ';' + upd + ')' + body)
forIn    trans:x trans:arr curlyTrans:body            -> ('for(' + x + ' in ' + arr + ')' + body)
begin    trans:x end                                  -> x
begin    (trans:x
          ( (?(x[x.length - 1] == '}') | end) -> x
          | empty                             -> (x  + ';')
          )
         )*:xs                                        -> ('{' + xs.join('') + '}')
func     :args curlyTrans:body                        -> ('(function (' + args.join(',') + ')' + body + ')')
call     trans:fn trans*:args                         -> (fn + '(' + args.join(',') + ')')
send     :msg trans:recv trans*:args                  -> (recv + '.' + msg + '(' + args.join(',') + ')')
new      :cls trans*:args                             -> ('new ' + cls + '(' + args.join(',') + ')')
var      :name trans:val                              -> ('var ' + name + '=Object.createVar(' + val + ')')
throw    trans:x                                      -> ('throw ' + x)
try      curlyTrans:x :name curlyTrans:c curlyTrans:f -> ('try ' + x + 'catch(' + name + ')' + c + 'finally' + f)
json     trans*:props                                 -> ('({' + props.join(',') + '})')
binding  :name trans:val                              -> (name.toProgramString() + ': ' + val)
switch   trans:x trans*:cases                         -> ('switch(' + x + '){' + cases.join(';') + '}')
case     trans:x trans:y                              -> ('case ' + x + ': '+ y)
default          trans:y                              -> ('default: ' + y)

grammar = trans*
