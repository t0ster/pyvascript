trans      = [:t apply(t):ans]     -> ans
curlyTrans = [`begin curlyTrans:r] -> r
         | [`begin trans*:rs]    -> ('{' + rs.join(';') + '}')
         | trans:r               -> ('{' + r + '}')

this                                                  -> 'this'
break                                                 -> 'break'
continue                                              -> 'continue'
number   :n                                           -> ('(' + n + ')')
string   :s                                           -> s.toProgramString()
arr      trans*:xs                                    -> ('[' + xs.join(',') + ']')
unop     :op trans:x                                  -> ('(' + op + ' ' + x + ')')
getp     trans:fd trans:x                             -> (x + '[' + fd + '].get()')
get      :x                                           -> (x + ".get()")
set      trans:lhs trans:rhs                          -> (lhs + '.set(' + rhs + ')')
mset     trans:lhs :op trans:rhs                      -> (lhs + op + '=' + rhs)
binop    :op trans:x trans:y                          -> ('(' + x + ' ' + op + ' ' + y + ')')
preop    :op trans:x                                  -> (x + '.set(x.get()' + op + '1)')
postop   :op trans:x                                  -> (x + op)
return   trans:x                                      -> ('return ' + x)
if       trans:cond curlyTrans:t curlyTrans:e         -> ('if(' + cond + ') ' + t + 'else' + e)
condExpr trans:cond trans:t trans:e                   -> ('(' + cond + '?' + t + ':' + e + ')')
while    trans:cond curlyTrans:body                   -> ('while(' + cond + ')' + body)
doWhile  curlyTrans:body trans:cond                   -> ('do' + body + 'while(' + cond + ')')
for      trans:init trans:cond trans:upd
         curlyTrans:body                              -> ('for(' + init + ';' + cond + ';' + upd + ')' + body)
forIn    trans:x trans:arr curlyTrans:body            -> ('for(' + x + ' in ' + arr + ')' + body)
begin    trans:x end                                  -> x
begin    (trans:x
          ( (?(x[x.length - 1] == '}') | end) -> x
          | empty                             -> (x  + ';')
          )
         )*:xs                                        -> ('{' + xs.join('') + '}')
func     :args curlyTrans:body                        -> ('(function (' + args.join(',') + ')' + body + ')')
call     trans:fn trans*:args                         -> (fn + '(' + args.join(',') + ')')
send     :msg trans:recv trans*:args                  -> (recv + '.' + msg + '(' + args.join(',') + ')')
new      :cls trans*:args                             -> ('new ' + cls + '(' + args.join(',') + ')')
var      :name trans:val                              -> ('var ' + name + '=Object.createVar(' + val + ')')
throw    trans:x                                      -> ('throw ' + x)
try      curlyTrans:x :name curlyTrans:c curlyTrans:f -> ('try ' + x + 'catch(' + name + ')' + c + 'finally' + f)
json     trans*:props                                 -> ('({' + props.join(',') + '})')
binding  :name trans:val                              -> (name.toProgramString() + ': ' + val)
switch   trans:x trans*:cases                         -> ('switch(' + x + '){' + cases.join(';') + '}')
case     trans:x trans:y                              -> ('case ' + x + ': '+ y)
default          trans:y                              -> ('default: ' + y)

grammar = trans*
